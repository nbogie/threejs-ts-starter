import { Color, Float32BufferAttribute, Mesh, MeshStandardMaterial, PlaneGeometry, Scene } from "three";
import { GUI } from "three/examples/jsm/libs/lil-gui.module.min.js";
import { SimplexNoise } from 'three/examples/jsm/math/SimplexNoise';

export interface NoiseValues {
    noiseVal: number;
    landHeight: number;
    colour: Color;
}

interface GridPos {
    col: number;
    row: number;
}

/** Add a grid of tiles (mesh objects) to the given scene, at different heights, to simulate (blocky) terrain.
* Heights (and colours) are calculated from an open-simplex noise algorithm (from a library).
*/
export function setupTerrain(scene: Scene, gridSize: number, gui: GUI): {
    updateTerrain: (time: number) => void
} {


    const options = {
        noiseScaling: 0.004,
        verticalScaling: 8,
        noiseAnimSpeed: 0,
        scrollSpeed: 2600,
        seaLevel: 0 /*relative to -1 to 1 */
    };

    const fbmOptions = {
        amps: [1.5, 0.6, 0.4, 0.2, 0.03, 0.02],
        freqs: [1, 2, 4, 8, 16, 96],
    }
    const coloursLookup = createColoursLookup();

    // initializing a new simplex instance
    // do this only once as it is relatively expensive
    const simplex = new SimplexNoise()

    const geometry = new PlaneGeometry(100, 100, gridSize - 1, gridSize - 1);
    geometry.rotateX(-Math.PI / 2)
    const groundMaterial = new MeshStandardMaterial({
        color: 0xFFFFFF,
        vertexColors: true,
    });
    const mesh = new Mesh(geometry, groundMaterial);
    scene.add(mesh)
    const guiTerrain = gui.addFolder("terrain")

    guiTerrain.add(options, 'noiseScaling', 0.00001, 0.01)
    guiTerrain.add(options, 'verticalScaling', 0.00001, 16)
    guiTerrain.add(options, 'noiseAnimSpeed', 0, 8)
    guiTerrain.add(options, 'scrollSpeed', 0, 2000)
    guiTerrain.add(options, 'seaLevel', -2, 2)

    const folderAmplitudes = guiTerrain.addFolder("fbm-amplitudes");
    for (let i = 0; i < fbmOptions.amps.length; i++) {
        folderAmplitudes.add(fbmOptions.amps, i, 0, 2);
    }

    const folderFrequencies = guiTerrain.addFolder("fbm-frequencies");
    for (let i = 0; i < fbmOptions.amps.length; i++) {
        folderFrequencies.add(fbmOptions.freqs, i, 0.1, 1 + i * i * i);
    }

    updateTerrain(0);

    /** Update position and colour of the terrain, based on the FBM noise for the given time.
     * @param time allows animation over time.
     */
    function updateTerrain(time: number) {
        //Useful reading: "how to update things"
        //https://threejs.org/docs/#manual/en/introduction/How-to-update-things

        //The types say geometry.attributes.position.array is read-only, 
        //but various official examples mutate it. ¯\_(ツ)_/¯
        const vertices = geometry.attributes.position.array as number[];

        const count = gridSize * gridSize;
        const colours: number[] = new Array(count * 3)


        for (let row = 0; row < gridSize; row++) {
            for (let col = 0; col < gridSize; col++) {
                const nvs = getNoiseValuesAtGridPos({ col, row }, time)

                const ix = 3 * (col + row * gridSize);
                const yPosIndex = ix + 1; //positions stored as x, y, z - we need the second of those.

                colours[ix + 0] = nvs.colour.r;
                colours[ix + 1] = nvs.colour.g;
                colours[ix + 2] = nvs.colour.b;

                vertices[yPosIndex] = nvs.landHeight;
            }
        }
        const colourBufferAttribute = new Float32BufferAttribute(colours, 3);
        geometry.setAttribute('color', colourBufferAttribute);

        //If you want to change the position data values after the first render, you need to set the needsUpdate flag like so:
        geometry.attributes.position.needsUpdate = true; // required after the first render

        //"If you change the position data values after the initial render, you may need to recompute bounding volumes so other features of the engine like view frustum culling or helpers properly work.""
        //geometry.computeBoundingBox();

        geometry.computeVertexNormals();
    }

    /** 
     * Return a noise value that is generated by adding many different frequencies of noise at different amplitudes, for more realistic terrain.
     *
     * * see https://thebookofshaders.com/13/
     * 
     * @returns number between -1 and 1, theoretically, though in practice it's unlikely you'll see a value beyond -0.8 to 0.8
     */

    function getFBMNoiseValAtGridPos(pos: GridPos, time: number): number {
        const timeAdjusted = time * options.noiseAnimSpeed;
        const zOffset = -time * options.scrollSpeed;

        const noiseVal1 = fbmOptions.amps[0] * simplex.noise3d(pos.col * options.noiseScaling * fbmOptions.freqs[0], (zOffset + pos.row) * options.noiseScaling * fbmOptions.freqs[0], timeAdjusted);
        const noiseVal2 = fbmOptions.amps[1] * simplex.noise3d(pos.col * options.noiseScaling * fbmOptions.freqs[1], (zOffset + pos.row) * options.noiseScaling * fbmOptions.freqs[1], timeAdjusted + 777);
        const noiseVal3 = fbmOptions.amps[2] * simplex.noise3d(pos.col * options.noiseScaling * fbmOptions.freqs[2], (zOffset + pos.row) * options.noiseScaling * fbmOptions.freqs[2], 3 * timeAdjusted + 999);
        const noiseVal4 = fbmOptions.amps[3] * simplex.noise3d(pos.col * options.noiseScaling * fbmOptions.freqs[3], (zOffset + pos.row) * options.noiseScaling * fbmOptions.freqs[3], 4 * timeAdjusted + 1333);
        const noiseVal5 = fbmOptions.amps[4] * simplex.noise3d(pos.col * options.noiseScaling * fbmOptions.freqs[4], (zOffset + pos.row) * options.noiseScaling * fbmOptions.freqs[4], 5 * timeAdjusted + 1999);
        const noiseVal6 = fbmOptions.amps[5] * simplex.noise3d(pos.col * options.noiseScaling * fbmOptions.freqs[5], (zOffset + pos.row) * options.noiseScaling * fbmOptions.freqs[5], 5 * timeAdjusted + 1777);
        const ampsSum = fbmOptions.amps.reduce((a, c) => a + c)
        const noiseVal = (noiseVal1 + noiseVal2 + noiseVal3 + noiseVal4 + noiseVal5 + noiseVal6) / ampsSum;
        return noiseVal;
    }

    /** Get noise-based values for the terrain at a given grid position 
     * @pos grid position to find out about
     * @time animation time
     * @returns noise values (including raw noiseVal, the landHeight and the terrain colour based on that noiseVal)
    */
    function getNoiseValuesAtGridPos(pos: GridPos, time: number): NoiseValues {
        const noiseVal = 2 * getFBMNoiseValAtGridPos(pos, time);
        const landHeight = (noiseVal < options.seaLevel ? options.seaLevel : noiseVal) * options.verticalScaling;
        const colour = getColorForNoiseVal(noiseVal);
        return { noiseVal, landHeight, colour }
    }


    function getColorForNoiseVal(noiseVal: number): Color {
        if (noiseVal < options.seaLevel - 0.3) {
            return coloursLookup.deepWater;
        }
        if (noiseVal < options.seaLevel) {
            return coloursLookup.shallowWater
        }
        if (noiseVal < options.seaLevel + 0.1) {
            return coloursLookup.sand
        }
        if (noiseVal < options.seaLevel + 0.7) {
            return coloursLookup.grass
        }
        if (noiseVal < options.seaLevel + 0.9) {
            return coloursLookup.rocks
        }
        return coloursLookup.snow
    }

    return { updateTerrain };
}


function createColoursLookup() {
    return {
        deepWater: new Color("navy"),
        shallowWater: new Color("dodgerblue"),
        sand: new Color("yellow"),
        grass: new Color("green"),
        rocks: new Color("gray"),
        snow: new Color("white"),
    }
}