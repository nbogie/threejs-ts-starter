import { BoxGeometry, Color, InstancedMesh, Matrix4, MeshStandardMaterial, PlaneGeometry, Scene } from "three";
import { SimplexNoise } from 'three/examples/jsm/math/SimplexNoise';

export interface NoiseValues {
    noiseVal: number;
    landHeight: number;
    colour: Color;
}

interface GridPos {
    col: number;
    row: number;
}

/** Add a grid of tiles (mesh objects) to the given scene, at different heights, to simulate (blocky) terrain.
 * Heights (and colours) are calculated from an open-simplex noise algorithm (from a library).
 */
export function setupTerrain(scene: Scene, gridSize: number): {
    updateTerrain: (time: number) => void
} {
    const coloursLookup = createColoursLookup();

    // initializing a new simplex instance
    // do this only once as it is relatively expensive
    const simplex = new SimplexNoise()

    const noiseScaling = 0.004;
    const verticalScaling = 8;
    const seaLevel = 0; //relative to simplex noise values of -1 to 1
    let geometry;
    const usePlanes = Math.random() < 0.5;
    if (usePlanes) {
        geometry = new PlaneGeometry(0.95, 0.95);//shared. For best performance consider THREE.InstancedMesh.
        geometry.rotateX(-Math.PI / 2)
    } else {
        geometry = new BoxGeometry(0.95, 0.1, 0.95);//shared. For best performance consider THREE.InstancedMesh.
    }

    const instancedMesh = new InstancedMesh(geometry,
        new MeshStandardMaterial(),
        gridSize * gridSize);

    // instancedMesh.instanceMatrix.setUsage(DynamicDrawUsage); // will be updated every frame

    updateTerrain(0);
    scene.add(instancedMesh)



    /** Update position and colour of all instances in the instanced mesh, based on the FBM noise for the given time.
     * @param time allows animation over time.
     */
    function updateTerrain(time: number) {
        for (let row = 0; row < gridSize; row++) {
            for (let col = 0; col < gridSize; col++) {
                updateInstancedMeshAtGridPos({ col, row }, time);
            }
        }
        instancedMesh.instanceMatrix.needsUpdate = true;
        if (instancedMesh.instanceColor) {
            instancedMesh.instanceColor.needsUpdate = true;
        }
    }

    /** Update position and colour of ONE instance of the instanced mesh, based on the FBM noise at that position for the given time 
     * @param gridPos gridPos of instance to update
     * @param time allows animation over time
    */
    function updateInstancedMeshAtGridPos(gridPos: GridPos, time: number) {
        const noiseVals = getNoiseValuesAtGridPos(gridPos, time);

        const matrix = new Matrix4();
        matrix.makeTranslation(
            gridPos.col - gridSize / 2,
            noiseVals.landHeight + 2,
            gridPos.row - gridSize / 2
        );

        const ix = gridPos.row * gridSize + gridPos.col;
        instancedMesh.setMatrixAt(ix, matrix);
        instancedMesh.setColorAt(ix, noiseVals.colour);
    }

    /** 
     * Return a noise value that is generated by adding many different frequencies of noise at different amplitudes, for more realistic terrain.
     *
     * * see https://thebookofshaders.com/13/
     * 
     * @returns number between -1 and 1, theoretically, though in practice it's unlikely you'll see a value beyond -0.8 to 0.8
     */
    function getFBMNoiseValAtGridPos(pos: GridPos, time: number): number {
        const noiseVal1 = 1.0 * simplex.noise3d(pos.col * noiseScaling, pos.row * noiseScaling, time);
        const noiseVal2 = 0.6 * simplex.noise3d(pos.col * noiseScaling * 2, pos.row * noiseScaling * 2, time + 777);
        const noiseVal3 = 0.4 * simplex.noise3d(pos.col * noiseScaling * 4, pos.row * noiseScaling * 4, time + 999);
        const noiseVal4 = 0.2 * simplex.noise3d(pos.col * noiseScaling * 8, pos.row * noiseScaling * 8, time + 1333);
        const noiseVal5 = 0.1 * simplex.noise3d(pos.col * noiseScaling * 16, pos.row * noiseScaling * 16, time + 1777);
        const noiseVal = (noiseVal1 + noiseVal2 + noiseVal3 + noiseVal4 + noiseVal5) / 2.3;
        return noiseVal;
    }

    /** Get noise-based values for the terrain at a given grid position 
     * @pos grid position to find out about
     * @time animation time
     * @returns noise values (including raw noiseVal, the landHeight and the terrain colour based on that noiseVal)
    */
    function getNoiseValuesAtGridPos(pos: GridPos, time: number): NoiseValues {
        const noiseVal = 2 * getFBMNoiseValAtGridPos(pos, time);
        const landHeight = (noiseVal < seaLevel ? seaLevel : noiseVal) * verticalScaling;
        const colour = getColorForNoiseVal(noiseVal);
        return { noiseVal, landHeight, colour }
    }


    function getColorForNoiseVal(noiseVal: number): Color {
        if (noiseVal < -0.3) {
            return coloursLookup.deepWater;
        }
        if (noiseVal < 0) {
            return coloursLookup.shallowWater
        }
        if (noiseVal < 0.1) {
            return coloursLookup.sand
        }
        if (noiseVal < 0.7) {
            return coloursLookup.grass
        }
        if (noiseVal < 0.9) {
            return coloursLookup.rocks
        }
        return coloursLookup.snow
    }

    return { updateTerrain };
}


function createColoursLookup() {
    return {
        deepWater: new Color("navy"),
        shallowWater: new Color("dodgerblue"),
        sand: new Color("yellow"),
        grass: new Color("green"),
        rocks: new Color("gray"),
        snow: new Color("white"),
    }
}