import { BoxGeometry, Color, Material, Mesh, MeshStandardMaterial, Scene } from "three";
import { SimplexNoise } from 'three/examples/jsm/math/SimplexNoise';

export interface NoiseValues { noiseVal: number, landHeight: number, material: Material }


interface GridPos {
    col: number;
    row: number;
}

/** Add a grid of tiles (mesh objects) to the given scene, at different heights, to simulate (blocky) terrain.
 * Heights (and colours) are calculated from an open-simplex noise algorithm (from a library).
 */
export function setupTerrain(scene: Scene): {
    tiles: Mesh[],
    animateTerrain: (time: number) => void
} {
    const materialsLookup = createMaterialsLookup();

    // initializing a new simplex instance
    // do this only once as it is relatively expensive
    const simplex = new SimplexNoise()

    const gridSize = 120;
    const noiseScaling = 0.004;
    const verticalScaling = 8;
    const seaLevel = 0; //relative to simplex noise values of -1 to 1
    const geometry = new BoxGeometry(1, 0.1, 1);//shared. For best performance consider THREE.InstancedMesh.

    const tiles: Mesh[] = [];
    for (let row = 0; row < gridSize; row++) {
        for (let col = 0; col < gridSize; col++) {
            const { landHeight, material } = getValuesAtGridPos({ col, row }, 0);

            //make a tile
            const oneTileMesh: Mesh = new Mesh(geometry, material);
            oneTileMesh.userData.gridPos = { col, row };

            //position the tile
            oneTileMesh.position.x = col - gridSize / 2;
            oneTileMesh.position.z = row - gridSize / 2;
            oneTileMesh.position.y = landHeight;

            scene.add(oneTileMesh);
            tiles.push(oneTileMesh)
        }
    }


    /** 
     * Return a noise value that is generated by adding many different frequencies of noise at different amplitudes, for more realistic terrain.
     *
     * * see https://thebookofshaders.com/13/
     * 
     * @returns number between -1 and 1, theoretically, though in practice it's unlikely you'll see a value beyond -0.8 to 0.8
     */
    function getFBMNoiseValAtGridPos(pos: GridPos, time: number): number {
        const noiseVal1 = 1.0 * simplex.noise3d(pos.col * noiseScaling, pos.row * noiseScaling, time);
        const noiseVal2 = 0.6 * simplex.noise3d(pos.col * noiseScaling * 2, pos.row * noiseScaling * 2, time + 777);
        const noiseVal3 = 0.4 * simplex.noise3d(pos.col * noiseScaling * 4, pos.row * noiseScaling * 4, time + 999);
        const noiseVal4 = 0.2 * simplex.noise3d(pos.col * noiseScaling * 8, pos.row * noiseScaling * 8, time + 1333);
        const noiseVal5 = 0.1 * simplex.noise3d(pos.col * noiseScaling * 16, pos.row * noiseScaling * 16, time + 1777);
        const noiseVal = (noiseVal1 + noiseVal2 + noiseVal3 + noiseVal4 + noiseVal5) / 2.3;
        return noiseVal;
    }

    //eslint-disable-next-line @typescript-eslint/no-unused-vars
    function getSimpleNoiseValAtGridPos(pos: GridPos, time: number): number {
        return simplex.noise3d(pos.col * noiseScaling, pos.row * noiseScaling, time);
    }

    function getValuesAtGridPos(pos: GridPos, time: number): NoiseValues {
        const noiseVal = 2 * getFBMNoiseValAtGridPos(pos, time);
        const landHeight = (noiseVal < seaLevel ? seaLevel : noiseVal) * verticalScaling;
        const material = getMaterialForNoiseVal(noiseVal);
        return { noiseVal, landHeight, material }
    }

    function getMaterialForNoiseVal(noiseVal: number): Material {
        if (noiseVal < -0.3) {
            return materialsLookup.deepWater;
        }
        if (noiseVal < 0) {
            return materialsLookup.shallowWater
        }
        if (noiseVal < 0.1) {
            return materialsLookup.sand
        }
        if (noiseVal < 0.7) {
            return materialsLookup.grass
        }
        if (noiseVal < 0.9) {
            return materialsLookup.rocks
        }
        return materialsLookup.snow
    }

    function animateTerrain(time: number): void {
        for (const tile of tiles) {
            const noiseValues = getValuesAtGridPos(tile.userData.gridPos, time);
            tile.position.y = noiseValues.landHeight;
            tile.material = noiseValues.material;
        }
    }

    return { tiles, animateTerrain };
}

function createMaterialsLookup() {
    return {
        deepWater: new MeshStandardMaterial({ color: new Color("navy") }),
        shallowWater: new MeshStandardMaterial({ color: new Color("dodgerblue") }),
        sand: new MeshStandardMaterial({ color: new Color("yellow") }),
        grass: new MeshStandardMaterial({ color: new Color("green") }),
        rocks: new MeshStandardMaterial({ color: new Color("gray") }),
        snow: new MeshStandardMaterial({ color: new Color("white") }),
    }
}